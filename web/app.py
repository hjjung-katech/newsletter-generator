"""
Newsletter Generator Web Service
Flask application that provides web interface for the CLI newsletter generator
"""

import os
import sys
from flask import Flask, render_template, request, jsonify, send_file
from flask_cors import CORS
import redis
from rq import Queue
import sqlite3
from datetime import datetime
import uuid
import json

# Add the parent directory to the path to import newsletter modules
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

# Create a simple mock for newsletter functionality until we can properly import it
class MockNewsletterCLI:
    def __init__(self):
        pass
    
    def generate_newsletter(self, keywords=None, domain=None):
        """Mock newsletter generation with more realistic content"""
        if keywords:
            keyword_list = [k.strip() for k in keywords.split(',')]
            title = f"Newsletter: {', '.join(keyword_list)}"
            
            content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }}
        .header {{ background: #f4f4f4; padding: 20px; text-align: center; }}
        .content {{ padding: 20px; }}
        .article {{ margin-bottom: 20px; padding: 15px; border-left: 3px solid #007bff; }}
        .article h3 {{ color: #007bff; margin-top: 0; }}
        .footer {{ background: #f4f4f4; padding: 15px; text-align: center; font-size: 0.9em; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>{title}</h1>
        <p>Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>
    <div class="content">
        <h2>Top Stories</h2>
"""
            
            for i, keyword in enumerate(keyword_list, 1):
                content += f"""
        <div class="article">
            <h3>{i}. Latest developments in {keyword}</h3>
            <p>This is a mock article about recent developments in {keyword}. In a real implementation, this would contain actual news content collected from various sources.</p>
            <p><strong>Key points:</strong></p>
            <ul>
                <li>Market trends and analysis for {keyword}</li>
                <li>Recent technological advancements</li>
                <li>Industry impact and future outlook</li>
            </ul>
        </div>
"""
            
            content += """
    </div>
    <div class="footer">
        <p>This newsletter was generated by Newsletter Generator Web Service</p>
        <p>For more information, visit our website</p>
    </div>
</body>
</html>
"""
            
        elif domain:
            title = f"Newsletter: {domain} Domain Insights"
            content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }}
        .header {{ background: #f4f4f4; padding: 20px; text-align: center; }}
        .content {{ padding: 20px; }}
        .section {{ margin-bottom: 30px; }}
        .section h3 {{ color: #007bff; border-bottom: 2px solid #007bff; padding-bottom: 5px; }}
        .footer {{ background: #f4f4f4; padding: 15px; text-align: center; font-size: 0.9em; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>{title}</h1>
        <p>Generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>
    <div class="content">
        <div class="section">
            <h3>Recent Developments in {domain}</h3>
            <p>Mock analysis of recent developments in the {domain} sector. This would contain real news and insights in the actual implementation.</p>
        </div>
        <div class="section">
            <h3>Key Trends</h3>
            <p>Analysis of key trends affecting the {domain} industry, including market movements and technological advances.</p>
        </div>
        <div class="section">
            <h3>Future Outlook</h3>
            <p>Forward-looking analysis and predictions for the {domain} sector based on current trends and market indicators.</p>
        </div>
    </div>
    <div class="footer">
        <p>This newsletter was generated by Newsletter Generator Web Service</p>
    </div>
</body>
</html>
"""
        else:
            title = "Sample Newsletter"
            content = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sample Newsletter</title>
</head>
<body>
    <h1>Sample Newsletter</h1>
    <p>No keywords or domain specified. Please provide either keywords or a domain for newsletter generation.</p>
</body>
</html>
"""
        
        return {
            'content': content,
            'title': title,
            'status': 'success'
        }

newsletter_cli = MockNewsletterCLI()

app = Flask(__name__)
CORS(app)  # Enable CORS for frontend-backend communication

# Configuration
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'dev-key-change-in-production')
app.config['REDIS_URL'] = os.environ.get('REDIS_URL', 'redis://localhost:6379/0')

# Redis connection with fallback to in-memory processing
try:
    redis_conn = redis.from_url(app.config['REDIS_URL'])
    redis_conn.ping()  # Test connection
    task_queue = Queue(connection=redis_conn)
    print("Redis connected successfully")
except Exception as e:
    print(f"Redis connection failed: {e}. Using in-memory processing.")
    redis_conn = None
    task_queue = None

# In-memory task storage for when Redis is unavailable
in_memory_tasks = {}

# Database initialization
DATABASE_PATH = os.path.join(os.path.dirname(__file__), 'storage.db')

def init_db():
    """Initialize SQLite database with required tables"""
    conn = sqlite3.connect(DATABASE_PATH)
    cursor = conn.cursor()
    
    # History table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS history (
            id TEXT PRIMARY KEY,
            params JSON NOT NULL,
            result JSON,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            status TEXT DEFAULT 'pending'
        )
    ''')
    
    # Schedules table for recurring newsletters
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS schedules (
            id TEXT PRIMARY KEY,
            params JSON NOT NULL,
            rrule TEXT NOT NULL,
            next_run TIMESTAMP NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            enabled INTEGER DEFAULT 1
        )
    ''')
    
    conn.commit()
    conn.close()

# Initialize database on startup
init_db()

@app.route('/')
def index():
    """Main dashboard page"""
    try:
        print(f"Template folder: {app.template_folder}")
        print(f"App root path: {app.root_path}")
        template_path = os.path.join(app.template_folder, 'index_en.html')
        print(f"Template path: {template_path}")
        print(f"Template exists: {os.path.exists(template_path)}")
        return render_template('index_en.html')
    except Exception as e:
        print(f"Template rendering error: {e}")
        return f"Template error: {str(e)}", 500

@app.route('/api/generate', methods=['POST'])
def generate_newsletter():
    """Generate newsletter based on keywords or domain"""
    data = request.get_json()
    
    if not data:
        return jsonify({'error': 'No data provided'}), 400
    
    # Create unique job ID
    job_id = str(uuid.uuid4())
    
    # Store request in history
    conn = sqlite3.connect(DATABASE_PATH)
    cursor = conn.cursor()
    cursor.execute(
        'INSERT INTO history (id, params, status) VALUES (?, ?, ?)',
        (job_id, json.dumps(data), 'pending')
    )
    conn.commit()
    conn.close()
      # If Redis is available, queue the task
    if task_queue:
        job = task_queue.enqueue('tasks.generate_newsletter_task', data, job_id)
        return jsonify({'job_id': job_id, 'status': 'queued'})
    else:
        # Fallback: process in background using in-memory tracking
        import threading
        
        # Store initial task status
        in_memory_tasks[job_id] = {
            'status': 'processing',
            'started_at': datetime.now().isoformat()
        }
        
        # Process in background thread
        def background_task():
            try:
                process_newsletter_in_memory(data, job_id)
                # Update database with final result
                conn = sqlite3.connect(DATABASE_PATH)
                cursor = conn.cursor()
                cursor.execute(
                    'UPDATE history SET result = ?, status = ? WHERE id = ?',
                    (json.dumps(in_memory_tasks[job_id]['result']), 'completed', job_id)
                )
                conn.commit()
                conn.close()
            except Exception as e:
                # Update database with error
                conn = sqlite3.connect(DATABASE_PATH)
                cursor = conn.cursor()
                cursor.execute(
                    'UPDATE history SET result = ?, status = ? WHERE id = ?',
                    (json.dumps({'error': str(e)}), 'failed', job_id)
                )
                conn.commit()
                conn.close()
        
        thread = threading.Thread(target=background_task)
        thread.daemon = True
        thread.start()
        
        return jsonify({'job_id': job_id, 'status': 'processing'})

def process_newsletter_sync(data):
    """Process newsletter synchronously (fallback when Redis is not available)"""
    try:
        # Extract parameters
        keywords = data.get('keywords', '')
        domain = data.get('domain', '')
        template_style = data.get('template_style', 'compact')
        
        # Use mock CLI for now
        if keywords:
            result = newsletter_cli.generate_newsletter(keywords=keywords)
        elif domain:
            result = newsletter_cli.generate_newsletter(domain=domain)
        else:
            raise ValueError("Either keywords or domain must be provided")
        
        return {
            'html_content': result['content'],
            'subject': result['title'],
            'articles_count': 5,
            'status': 'success'
        }
    except Exception as e:
        raise Exception(f"Newsletter generation failed: {str(e)}")

def process_newsletter_in_memory(data, job_id):
    """Process newsletter in memory and update task status"""
    try:
        result = process_newsletter_sync(data)
        in_memory_tasks[job_id] = {
            'status': 'completed',
            'result': result,
            'updated_at': datetime.now().isoformat()
        }
        return result
    except Exception as e:
        in_memory_tasks[job_id] = {
            'status': 'failed',
            'error': str(e),
            'updated_at': datetime.now().isoformat()
        }
        raise e

@app.route('/api/status/<job_id>')
def get_job_status(job_id):
    """Get status of a newsletter generation job"""
    # Check in-memory tasks first (for non-Redis mode)
    if job_id in in_memory_tasks:
        task = in_memory_tasks[job_id]
        response = {
            'job_id': job_id,
            'status': task['status']
        }
        
        if 'result' in task:
            response['result'] = task['result']
        if 'error' in task:
            response['error'] = task['error']
        
        return jsonify(response)
    
    # Fallback to database
    conn = sqlite3.connect(DATABASE_PATH)
    cursor = conn.cursor()
    cursor.execute('SELECT params, result, status FROM history WHERE id = ?', (job_id,))
    row = cursor.fetchone()
    conn.close()
    
    if not row:
        return jsonify({'error': 'Job not found'}), 404
    
    params, result, status = row
    response = {
        'job_id': job_id,
        'status': status,
        'params': json.loads(params) if params else None
    }
    
    if result:
        response['result'] = json.loads(result)
    
    return jsonify(response)

@app.route('/api/history')
def get_history():
    """Get recent newsletter generation history"""
    conn = sqlite3.connect(DATABASE_PATH)
    cursor = conn.cursor()
    cursor.execute(
        'SELECT id, params, result, created_at, status FROM history ORDER BY created_at DESC LIMIT 20'
    )
    rows = cursor.fetchall()
    conn.close()
    
    history = []
    for row in rows:
        job_id, params, result, created_at, status = row
        history.append({
            'id': job_id,
            'params': json.loads(params) if params else None,
            'result': json.loads(result) if result else None,
            'created_at': created_at,
            'status': status
        })
    
    return jsonify(history)

@app.route('/api/schedule', methods=['POST'])
def create_schedule():
    """Create a recurring newsletter schedule"""
    data = request.get_json()
    
    if not data or not data.get('rrule') or not data.get('email'):
        return jsonify({'error': 'Missing required fields: rrule, email'}), 400
    
    schedule_id = str(uuid.uuid4())
    
    # Parse RRULE to calculate next_run (simplified for now)
    # In production, use proper RRULE library
    next_run = datetime.now().isoformat()
    
    conn = sqlite3.connect(DATABASE_PATH)
    cursor = conn.cursor()
    cursor.execute(
        'INSERT INTO schedules (id, params, rrule, next_run) VALUES (?, ?, ?, ?)',
        (schedule_id, json.dumps(data), data['rrule'], next_run)
    )
    conn.commit()
    conn.close()
    
    return jsonify({'status': 'scheduled', 'schedule_id': schedule_id}), 201

@app.route('/api/schedules')
def get_schedules():
    """Get all active schedules"""
    conn = sqlite3.connect(DATABASE_PATH)
    cursor = conn.cursor()
    cursor.execute(
        'SELECT id, params, rrule, next_run, created_at, enabled FROM schedules WHERE enabled = 1'
    )
    rows = cursor.fetchall()
    conn.close()
    
    schedules = []
    for row in rows:
        schedule_id, params, rrule, next_run, created_at, enabled = row
        schedules.append({
            'id': schedule_id,
            'params': json.loads(params) if params else None,
            'rrule': rrule,
            'next_run': next_run,
            'created_at': created_at,
            'enabled': bool(enabled)
        })
    
    return jsonify(schedules)

@app.route('/api/schedule/<schedule_id>', methods=['DELETE'])
def delete_schedule(schedule_id):
    """Cancel a recurring schedule"""
    conn = sqlite3.connect(DATABASE_PATH)
    cursor = conn.cursor()
    cursor.execute('UPDATE schedules SET enabled = 0 WHERE id = ?', (schedule_id,))
    affected = cursor.rowcount
    conn.commit()
    conn.close()
    
    if affected == 0:
        return jsonify({'error': 'Schedule not found'}), 404
    
    return jsonify({'status': 'cancelled'})

@app.route('/health')
def health_check():
    """Health check endpoint for Railway"""
    return jsonify({
        'status': 'healthy',
        'redis_connected': redis_conn is not None,
        'database': 'sqlite'
    })

@app.route('/test')
def test():
    """Simple test route"""
    return "Flask is working! Template folder: " + str(app.template_folder)

@app.route('/test-template')
def test_template():
    """Test template rendering"""
    try:
        return render_template('test.html')
    except Exception as e:
        return f"Template error: {str(e)}", 500

@app.route('/test-api')
def test_api():
    """API test page"""
    return render_template('test.html')

@app.route('/manual-test')
def manual_test():
    """Manual test page for newsletter generation workflow"""
    return render_template('manual_test.html')

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5000))
    debug = os.environ.get('FLASK_ENV') == 'development'
    print(f"Starting Flask app on port {port}, debug={debug}")
    app.run(host='0.0.0.0', port=port, debug=True)
